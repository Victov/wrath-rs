pub mod constants;
mod update_data;
pub use update_data::UpdateData;

use crate::character::Character;
use crate::guid::{Guid, WriteGuid};
use anyhow::Result;
use constants::{ObjectType, ObjectUpdateFlags, ObjectUpdateType};
use podio::{LittleEndian, WritePodExt};
use std::io::Cursor;

pub trait Updateable {
    fn get_update_flags(&self) -> u32;
    fn get_guid(&self) -> &Guid;
    fn get_object_type(&self) -> u32;
    fn get_object_type_mask(&self) -> u32;

    fn is_type(&self, obj_type: ObjectType) -> bool {
        self.get_object_type_mask() & (1 << obj_type as u32) > 0
    }
}

//https://www.ownedcore.com/forums/world-of-warcraft/world-of-warcraft-emulator-servers/wow-emu-questions-requests/390468-smsg_update_object-documentation.html

pub fn build_create_update_block_for_player<T: Updateable>(update_data: &mut UpdateData, for_player: &Character, subject: &T) -> Result<()> {
    let mut update_type = ObjectUpdateType::CreateObject as u8;
    let mut update_flags = subject.get_update_flags() as u16;
    let object_type = subject.get_object_type() as u8;

    if &for_player.guid == subject.get_guid() {
        update_flags |= ObjectUpdateFlags::FlagSelf as u16;
    }

    if update_flags & ObjectUpdateFlags::Position as u16 > 0 {
        if subject.is_type(ObjectType::DynamicObject) || subject.is_type(ObjectType::Corpse) || subject.is_type(ObjectType::Player) {
            update_type = ObjectUpdateType::CreateObject2 as u8;
        }
    }

    let mut writer = Cursor::new(Vec::<u8>::new());
    writer.write_u8(update_type)?;
    writer.write_packed_guid(&subject.get_guid())?; //client will not accept this yet, since this packed guid needs to match up with guid values in the VALUES block, but those are still hardcoded
    writer.write_u8(object_type)?;

    build_movement_update(&mut writer, subject)?;
    build_values_update(&mut writer, subject)?;

    update_data.add_block(&writer.into_inner());

    Ok(())
}

fn build_movement_update<T: Updateable>(writer: &mut Cursor<Vec<u8>>, _subject: &T) -> Result<()> {
    use std::io::Write;

    //Temporarily hardcoded for now

    writer.write(&[
        0x21, 0x00, // Update Flags -> Living | Self
        0x00, 0x00, 0x00, 0x00, // Movement Flags
        0x00, 0x00, // Extra Movement Flags
        0x00, 0x00, 0x00, 0x00, // Fake Time Stamp
        0xcd, 0xd7, 0x0b, 0xc6, // x
        0x35, 0x7e, 0x04, 0xc3, // y
        0xf9, 0x0f, 0xa7, 0x42, // z
        0x00, 0x00, 0x00, 0x00, // o
        0x00, 0x00, 0x00, 0x00, // Fall Time
        0x00, 0x00, 0x80, 0x3f, // Walk Speed (1.0f)
        0x00, 0x00, 0x8c, 0x42, // Run Speed (70.0f -> really fast ^^)
        0x00, 0x00, 0x90, 0x40, // Run Back Speed (4.5f)
        0x00, 0x00, 0x00, 0x00, // Swim Speed (swimming isn't enabled so we set this speed to 0)
        0x00, 0x00, 0x00, 0x00, // Swim Back Speed (see Swim Speed)
        0x00, 0x00, 0x00, 0x00, // Fly Speed (flying isn't enabled so we set this speed to 0)
        0x00, 0x00, 0x00, 0x00, // Fly Back Speed (see Fly Speed)
        0x00, 0x0f, 0x49, 0x40, // Turn Speed - how fast a character can turn around z axis (3.1415405f)
        0x00, 0x00, 0x00, 0x00, // Pitch Rate (flying is disabled, so this is set to 0)
    ])?;

    Ok(())
}

fn build_values_update<T: Updateable>(writer: &mut Cursor<Vec<u8>>, subject: &T) -> Result<()> {
    use std::io::Write;

    writer.write(&[
        0x2a, // Mask Size ((1326 + 31) / 32 = 42)
        0b00010111, 0x00, 0x80, 0x01, 0x01, 0x00, 0b11000000, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ])?;

    writer.write_u32::<LittleEndian>(subject.get_guid().get_low_part())?;
    writer.write_u32::<LittleEndian>(subject.get_guid().get_high_part())?;

    writer.write(&[
        0x19, 0x00, 0x00, 0x00, // OBJECT_FIELD_TYPE -> unit | player | object
        0x00, 0x00, 0x80, 0x3f, // OBJECT_FIELD_SCALE_X
        0x01, 0x01, 0x01, 0x01, // UNIT_FIELD_BYTES_0 Race(Human), Class(Warrior), Gender(Female), PowerType(Rage)
        0x3c, 0x00, 0x00, 0x00, // UNIT_FIELD_HEALTH
        0x3c, 0x00, 0x00, 0x00, // UNIT_FIELD_MAXHEALTH
        0x01, 0x00, 0x00, 0x00, // UNIT_FIELD_LEVEL
        0x01, 0x00, 0x00, 0x00, // UNIT_FIELD_FACTIONTEMPLATE [Required]
        0x0c, 0x4d, 0x00, 0x00, // UNIT_FIELD_DISPLAYID (Human Female = 19724) [Required]
        0x0c, 0x4d, 0x00, 0x00,
    ])?;

    Ok(())
}
